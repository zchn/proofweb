let read_file name =
  let inp = open_in name in
  let str = ref "" in
  try while true do str := !str ^ input_line inp ^ "\n"; done; ""
  with End_of_file -> (try close_in inp with _ -> ()); !str
;;


let replace pat out s =
  fst (Xstr_match.replace_matched_substrings [Xstr_match.Literal pat] [Xstr_match.ReplaceLiteral out] [] s)
;;

let replace_list = List.fold_left (fun s (p, o) -> replace p o s);;

let remove_ml_comment str =
  fst (Xstr_match.replace_matched_substrings [Xstr_match.Literal "(*"; Xstr_match.Anystring_from (Xstr_match.mknegset "*"); Xstr_match.Literal "*)"] [Xstr_match.ReplaceLiteral " "] [] str)
;;

let list_begin_matcher lst =
  let mapper s = if s.[0] = '\\' then s else "\\b" ^ s ^ "\\b" in
  let matches = String.concat "|" (List.map mapper lst) in
  let rex = Pcre.regexp ("^( |\n|\r|\t|<br>|<BR>|<BR/>|<BR />)*(" ^ matches ^ ")") in
  fun s -> Pcre.pmatch ~rex s
;;

let string_list_of_string str sep =
  let rec slos_aux str ans =
    if str = "" then List.rev ans else
    try
      let first_space = String.index str sep in
      if first_space = 0 then
        slos_aux (String.sub str 1 (String.length str - 1)) ans
      else
        slos_aux
          (String.sub str (first_space + 1)(String.length str - 1 - first_space))
          ((String.sub str 0 (first_space)) :: ans)
    with
      Not_found ->
        List.rev (str :: ans)
  in slos_aux str []
;;

let int_of_string_space str = 
  let lst = string_list_of_string str ' ' in
  int_of_string (List.hd lst)
;;

let rec whichlist p = function
  | [] -> raise Not_found
  | h :: t -> if p h then 0 else (1 + whichlist p t)
;;

let rec removelist n = function
  | [] -> []
  | h :: t -> if n > 0 then removelist (n - 1) t else h :: t
;;

let containslist l1 l2 =
  List.fold_left (fun ok e -> ok && List.mem e l1) true l2 
;;

(*
let send_email address =
  let pandora = Unix.ADDR_INET (Unix.inet_addr_of_string "131.174.33.4", 25) in
  let inc, outc = Unix.open_connection pandora in
  print_endline (input_line inc);
  output_string outc "EHLO hair-dryer.cs.ru.nl\r\n";
  output_string outc "MAIL FROM: <cek@cs.ru.nl>\r\n";
  output_string outc ("RCPT TO: " ^ address ^ "\r\n");
  output_string outc "DATA\r\n";
  output_string outc ("From: Cezary Kaliszyk (autogenerated) <cek@cs.ru.nl>\r\nTo: " ^ address ^ "\r\nSubject: Coq web interface password\r\nCongratulations, \r\nThe password is\r\n  " ^ !Options.pass ^ "\r\nYou can log in at http://hair-dryer.cs.ru.nl/\r\n");
  output_string outc "QUIT\r\n"; flush outc;
  (try while true do
    printf " @\n" (input_line inc);
    flush stdout;
  done with _ -> ());
  close_in inc
;;
*)

let log frmt = Format.fprintf !Options.log_f frmt;;

let save_log_chan = open_out_gen [Open_append;Open_wronly;Open_creat] 0o644 "/savelog";;
let save_log_f = Format.formatter_of_out_channel save_log_chan;;

let save_log frmt = Format.fprintf save_log_f frmt;;
  
let time_log frmt =
  let tim = Unix.localtime (Unix.time ()) in
  log "[%02i/%02i/%02i %02i:%02i:%02i] "
    (tim.Unix.tm_year - 100) (tim.Unix.tm_mon + 1) tim.Unix.tm_mday 
    tim.Unix.tm_hour tim.Unix.tm_min tim.Unix.tm_sec;
  log frmt
;;

let readdir dir =
  let handle = Unix.opendir dir in
  let lst = ref [] in
  (try while true do lst := Unix.readdir handle :: !lst done with _ -> ());
  Unix.closedir handle;
  List.sort compare (List.filter (fun x -> x.[0] <> '.') !lst)
;;

let read_comma_separated name =
  let inc = open_in name in
  let rec read_aux a =
    try
      let line = input_line inc in
      let s = string_list_of_string line ',' in
      read_aux (s :: a)
    with End_of_file -> a
  in
  let ret = read_aux [] in
  close_in inc;
  ret
;;

let read_comma_pairs name =
  let l = read_comma_separated name in
  List.map (fun s -> ((List.hd s), List.hd (List.tl s))) l
;;

let login_page (cgi:Netcgi_types.cgi_activation) =
  let ip = cgi#environment#cgi_remote_addr in
  let user = cgi#environment#input_header_field ~default:"" "user-agent" in
  time_log "%15s V %s@." ip user;
  cgi#set_redirection_header "login.php";
  cgi # output # commit_work () 
;;

(*let login_page (cgi:Netcgi_types.cgi_activation) =
  let login_page = read_file "/pub/login.html" in
  let ip = cgi#environment#cgi_remote_addr in
  let user = cgi#environment#input_header_field ~default:"" "user-agent" in
  time_log "%15s V %s@." ip user;
  cgi # set_header ~content_type:"text/html" ();
  cgi # output # output_string login_page;                                                        
  cgi # output # commit_work () 
;;*)

external set_close_on_exec : Unix.file_descr -> unit = "unix_set_close_on_exec";;

let try_set_close_on_exec fd =
  try set_close_on_exec fd; true with Invalid_argument _ -> false
;;

let open_proc_full cmd env input output error toclose =
  let cloexec = List.for_all try_set_close_on_exec toclose in
  match Unix.fork() with
     0 -> Unix.dup2 input Unix.stdin; Unix.close input;
          Unix.dup2 output Unix.stdout; Unix.close output;
          Unix.dup2 error Unix.stderr; Unix.close error;
          if not cloexec then List.iter Unix.close toclose;
          begin try Unix.execve "/bin/sh" [| "/bin/sh"; "-c"; cmd |] env
          with _ -> exit 127
          end
  | id -> id
;;

let open_process_full cmd env =
  let (in_read, in_write) = Unix.pipe() in
  let (out_read, out_write) = Unix.pipe() in
  let (err_read, err_write) = Unix.pipe() in
  let inchan = Unix.in_channel_of_descr in_read in
  let outchan = Unix.out_channel_of_descr out_write in
  let errchan = Unix.in_channel_of_descr err_read in
  let id = open_proc_full cmd env out_read in_write err_write [in_read; out_write; err_read] in
  Unix.close out_read;
  Unix.close in_write;
  Unix.close err_write;
  (inchan, outchan, errchan, id)
;;

